---
title: "[ SQL 첫걸음 ] 제 2장 테이블에서 데이터 검색"
description: "[ SQL 첫걸음 ] 제 2장 테이블에서 데이터 검색"
tags:
    - "2021"
    - SQL
---

# [ SQL 첫걸음 ] 제 2장 테이블에서 데이터 검색

!!! note "참고"
    [SQL 첫걸음](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&barcode=9788968482311)을 참고로 공부한 내용입니다. 따라서 아래 명령어를 통해 나오게 되는 결괏값은 전부 해당 책을 통해 다운로드한 파일의 결과물입니다.


## 04강 Hello World 실행하기

### `SELECT * FROM 테이블명` 실행

`SELECT` 명령을 사용하여 아래와 같이 조회 기능을 수행할 수 있습니다. 이때 명령문의 마지막에 반드시 세미콜론(`;`)을 사용해야 하며 그렇지 않을 경우 명령을 계속해서 이어 입력하는 걸로 인지합니다.

<div class="termy">
    ```sh
    $ mysql > SELECT * FROM sample21;

    +------+-----------+------------+---------------------------+
    | no   | name      | birthday   | address                   |
    +------+-----------+------------+---------------------------+
    |    1 | 박준용      | 1976-10-18 | 대구광역시 수성구             |
    |    2 | 김재진      | NULL       | 대구광역시 동구              |
    |    3 | 홍길동      | NULL       | 서울특별시 마포구             |
    +------+-----------+------------+---------------------------+
    3 rows in set (0.01 sec)
    ```

</div>

!!! info "정보"

    사실 굳이 명령을 대문자로 쓸 필요는 없습니다.

    예를 들어 위 명령문은 `select * from sample21;`와 같이 입력해도 동일한 결괏값을 반환합니다.

### `SELECT` 명령 구분

`SELECT`는 DML에 속하는 명령으로 **질의** 또는 **쿼리**라 부르기도 합니다.

만약 위 명령문 `SELECT * FROM sample21;`을 다시 살펴보면 애스터리스크(`*`)의 경우 원래 열이 들어가는 자리로 애스터리스크(`*`)는 모든 열을 의미하는 메타문자이고 `FROM`은 처리 대상 테이블을 지정하는 키워드입니다.

결론적으로 `SELECT * FROM sample21;` 명령문을 해석하면 `sample21`이라는 테이블로부터 모든 열(`*`)을 조회(`SELECT`)하라는 뜻입니다.

!!! info "정보"

    SQL 명령은 키워드에 의해 **구**라는 단위로 나눌 수 있습니다.

    `SELECT * FROM sample21;` 명령문의 경우 `SELECT` 구와 `FROM` 구로 나눌 수 있습니다.

    이때 `SELECT` 명령은 다시 여러 개의 구로 구성되는데 이는 추후 살펴볼 예정입니다.


### 예약어와 데이터베이스 객체명

`SELECT`와 `FROM`이 구를 결정하는 **키워드**면서 동시에 **예약어**입니다.

데이터베이스에는 테이블 외에도 다양한 데이터를 저장하거나 관리하는 **객체(Object)**를 만들 수 있습니다. 대표적으로 **뷰(View)**가 이에 해당하는데 관련해서는 추후에 더 자세히 살펴볼 예정입니다. 이때 각 개체에 이름을 붙여 관리합니다. 따라서 `sample21`이라는 테이블 객체가 이미 존재하기 때문에 동일한 이름의 객체를 생성할 수 없습니다.

!!! warning "주의"

    예약어 또한 객체명으로 사용하지 못합니다. 따라서 `SELECT`라는 테이블을 생성할 수 없습니다.

#### 대소문자 구별

예약어와 데이터베이스 객체명은 대소문자를 구별하지 않습니다. 따라서 아래 세 명령문은 모두 동일하게 작동합니다.

```sql
select * from sample21;
SELECT * FROM sample21;
Select * From Sample21;
```

!!! warning "주의"

    SQL과 달리 많은 데이터베이스 제품들은 데이터의 대소문자를 구별합니다.

### Hello World를 실행한 결고 = 테이블

`SELECT` 명령을 통해 표 형식의 데이터가 출력되는 것을 확인했습니다. 표 형식의 데이터는 **행(레코드)**과 **열(컬럼/필드)**로 구성됩니다. 그리고 각 행과 열이 만나는 부분을 **셀**이라 합니다. 따라서 셀에는 하나의 데이터 값이 저장되어 있습니다. 이때 데이터는 자료형으로 분류가 가능한데 아래 예시를 한 번 살펴봅시다.

```sql
+------+-----------+------------+---------------------------+
| no   | name      | birthday   | address                   |
+------+-----------+------------+---------------------------+
|    1 | 박준용      | 1976-10-18 | 대구광역시 수성구             |
|    2 | 김재진      | NULL       | 대구광역시 동구              |
|    3 | 홍길동      | NULL       | 서울특별시 마포구             |
+------+-----------+------------+---------------------------+
```

* `no`과 같이 숫자로만 구성된 데이터를 **수치형** 데이터라고 합니다.
* `name`과 같이 문자로 구성된 데이터를 **문자열형** 데이터라고 합니다.
* `birtday`와 같이 날짜와 시간으로 구성된 데이터를 **날짜시간형** 데이터라고 합니다.

!!! warning "주의"

    이때 각 열은 하나의 자료형만 가질 수 있습니다. 따라서 하나의 열이 수치형 데이터이면서 동시에 문자열형 데이터일 수는 없습니다.

### 값이 없는 데이터 = `NULL`

위 결괏값에서 `birthday` 열의 값을 잘 보면 `NULL`이라는 값을 확인할 수 있습니다. `NULL`은 아무것도 저장되어 있지 않은 상태를 의미합니다.


## 05강 테이블 구조 참조하기

`SELECT` 명령에 애스터리스크(`*`)를 사용하여 모든 열을 조회했습니다. 어떤 열이 존재하는 지 알면 원하는 열만 참조할 수 있게 됩니다. 열에 관한 정보를 알 수 있는 방법, 다시 말해 테이블 구조를 참조하는 방법은 바로 `DESC` 명령을 사용하는 것입니다.

### `DESC` 명령

`sample21` 테이블의 구조를 참조하면 아래와 같은 결괏값이 출력됩니다.

<div class="termy">
    ```sh
    $ mysql > DESC sample21;

    +----------+-------------+------+-----+---------+-------+
    | Field    | Type        | Null | Key | Default | Extra |
    +----------+-------------+------+-----+---------+-------+
    | no       | int         | YES  |     | NULL    |       |
    | name     | varchar(20) | YES  |     | NULL    |       |
    | birthday | date        | YES  |     | NULL    |       |
    | address  | varchar(40) | YES  |     | NULL    |       |
    +----------+-------------+------+-----+---------+-------+
    4 rows in set (0.00 sec)
    ```

</div>

이처럼 `DESC` 명령을 통해 테이블 구조를 참조할 수 있게 됩니다.

* `Field` : 열 이름을 보여줍니다..
* `Type` : 자료형을 보여줍니다. 예를 들어 `int`는 정수(Integer)를, `varchar`는 문자열을 의미합니다. 이때 `varchar(20)`와 같이 괄호에 숫자가 적혀있는 부분은 최댓값을 의미합니다. 따라서 `varchar(20)`은 최대 길이가 20자인 문자열 자료형을 의미합니다.
* `Null` : `Null` 값을 허용할 것인지 아닌지를 나타내는 **제약사항**입니다. 따라서 `Yes`는 다시 말해 해당 열에 `Null` 값이 들어가도 괜찮다는 것을 의미합니다.
* `Key` : 해당 열이 키(Key)로 지정되어 있는지를 보여줍니다.
* `Default` : 값을 생략했을 때 주어지는 기본값을 보여줍니다. 만약 `Default`가 존재한다면 행을 추가할 때 해당 열의 데이터 값이 생략되어 있더라도 `Default` 값이 자동으로 할당됩니다.

!!! warning "주의"

    `DESC` 명령어는 MySQL 명령입니다. 따라서 다른 SQL, 예를 들어 PostgreSQL에서 동일한 결과를 출력하고 싶다면 `DESC` 대신 `\d+`를 사용해야 합니다.

### 자료형

열에 지정할 수 있는 자료형의 종류에 대해서 알아보려 합니다.

#### INTEGER

수치형의 하나로 정수값을 지정할 수 있는 자료형입니다. 정수값을 지정할 수 있기 때문에 값에 소수점을 포함할 수 없습니다.

#### CHAR

문자열형의 하나로 문자열을 저장할 수 있는 자료형입니다. 문자열형에서는 앞서 `varchar(20)`와 같이 열의 최대 길이를 지정해야합니다. 다음에 살펴볼 VARCHAR와 달리 CHAR의 경우 언제나 고정된 길이로 데이터가 저장되는 자료형으로 **고정 길이 문자열** 자료형이라고도 부릅니다. 따라서 길이가 고정되기 때문에 최대 길이보다 작은 문자열을 저장할 경우 공백문자로 나머지를 채운 후 저장하게 됩니다.

#### VARCHAR

문자열을 저장할 수 있는 자료형입니다. 최대 길이를 지정해야 하는 점은 CHAR와 동일하지만 데이터 크기에 맞춰 저장공간의 크기도 변경되기 때문에 **가변 길이 문자열** 자료형이라고도 부릅니다.

#### DATE

날짜값을 저장할 수 있는 자료형입니다. 여기서 날짜값이란 `2021년 12월 4일`과 같이 연월일 형태의 데이터를 의미합니다.

#### TIME

시간을 저장할 수 있는 자료형입니다. 예슬 들어 `12시 30분 20`초와 같은 시분초 형태의 데이터를 의미합니다.

## 06강 검색 조건 지정하기

실제 데이터베이스에서 어떤 데이터를 조회할 때는 테이블 내에 존재하는 모든 데이터를 조회하는 것보다 특정 조건에 맞는 데이터만을 조회하는 게 더 효율적일 것입니다. 예를 들어 게시판에서 인기 게시글만 조회하는 경우와 같습니다.

이러한 맥락에서 효율적인 조회를 위해서는 열과 행을 잘 선택해야 합니다. 이전에 **열**을 지정할 때 `SELECT` 구를 사용한 것처럼 **행**을 지정할 때는 `WHERE` 구를 사용합니다.

### `SELECT` 구에서 열 지정하기

열을 한정하는 방법은 이전에 애스터리스크(`*`)를 사용해 전체 열을 선택했던 것과 달리 원하는 열만 지정하여 입력하면 됩니다. 아래 예시를 한 번 살펴보겠습니다.

<div class="termy">
    ```sh
    $ mysql > SELECT no, name FROM sample21;

    +------+-----------+
    | no   | name      |
    +------+-----------+
    |    1 | 박준용      |
    |    2 | 김재진      |
    |    3 | 홍길동      |
    +------+-----------+
    3 rows in set (0.00 sec)
    ```

</div>

열에 `no`, `name`을 지정하여 `no`과 `name` 열만을 조회하였습니다.

이때 열을 지정하는 순서는 임의로 정할 수 있습니다. 따라서 `SELECT no, name FROM sample21;` 명령문이나 `SELECT name, no FROM sample21;` 명령문의 결괏값은 동일하나 출력 형태는 조금 다릅니다. 지정한 열에 따라 그 순서가 달라집니다.

<div class="termy">
    ```sh
    $ mysql > SELECT name, no FROM sample21;

    +-----------+------+
    | name      | no   |
    +-----------+------+
    | 박준용    |    1   |
    | 김재진    |    2   |
    | 홍길동    |    3   |
    +-----------+------+
    3 rows in set (0.00 sec)
    ```

</div>

또한 `SELECT no, no, no FROM sample21;` 명령문과 같이 동일한 열을 중복해서 지정해도 무관합니다. 이때 해당 중복된 열 모두를 결괏값으로 출력합니다.

<div class ="termy">
    ```sh
    $ mysql > SELECT no, no, no FROM sample21;

    +------+------+------+
    | no   | no   | no   |
    +------+------+------+
    |    1 |    1 |    1 |
    |    2 |    2 |    2 |
    |    3 |    3 |    3 |
    +------+------+------+
    3 rows in set (0.00 sec)
    ```

</div>

!!! warning "주의"

    열을 지정할 때 `SELECT FROM sample21;`과 같이 아무런 열도 지정하지 않거나 존재하지 않는 열을 지정할 경우 오류가 발생합니다.


### `WHERE` 구에서 행 지정하기

`SELECT`가 **열**을 지정했다면 `WHERE`은 **행**을 지정합니다. 그 명령문의 형태는 `SELECT 열 FROM 테이블명 WHERE 조건식`과 같습니다. 조건식에 일치하는 행만 `SELECT`의 결과로 반환됩니다.

#### 구의 순서와 생략

SQL에서는 구의 순서가 정해져 있어 바꿔적을 수 없습니다. 따라서 `SELECT 열 WHERE 조건식 FROM 테이블명`과 같이 이미 정해져있는 구의 순서를 바꿔서 명령문을 실행할 경우 오류가 발생합니다.

앞서 `SELECT * FROM sample21;` 명령문에서 `WHERE` 구가 생략된 것처럼 구 중에는 생략 가능한 구도 존재합니다. `WHERE` 구를 생략할 경우 테이블 내의 모든 행이 대상이 됩니다.

#### `WEHRE` 구

만약 아래와 같은 테이블 `sample21`이 존재한다고 해봅시다.

```sql
+------+-----------+
| no   | name      |
+------+-----------+
|    1 | 박준용      |
|    2 | 김재진      |
|    3 | 홍길동      |
+------+-----------+
```

이때 `no`의 값이 `2`인 데이터만 조회하기를 원한다면 아래와 같이 명령문을 입력하면 됩니다.

<div class="termy">
    ```sh
    $ mysql > SELECT no, name FROM sample21 WHERE no=2;

    +------+-----------+
    | no   | name      |
    +------+-----------+
    |    2 | 김재진      |
    +------+-----------+
    1 row in set (0.00 sec)
    ```

</div>

#### 조건식

위 예시에서 `WHERE no=2`는 `no` 열 값이 `2`인 경우에 참이 되는 조건입니다. 해당 조건식을 조금 더 세분화하면 다음과 같습니다.

* `no` : 첫 번째 항목으로 열 이름입니다.
* `=` : 두 번째 항목으로 연산자입니다.
* `2` : 마지막 항목으로 값입니다.

이처럼 해당 열(`no`)에 조건, 다시 말해 값(`2`)이 연산자(`=`)에 일치하는 경우를 반환합니다.

#### 값이 서로 다른 경우 `<>`

비교 연산자의 종류에는 `=` 외에도 존재합니다. `<>`을 사용할 경우 그 값이 아닌 행만 반환합니다. 아래 예시를 한 번 살펴봅시다.

<div class="termy">
    ```sh
    $ mysql > SELECT no, name FROM sample21 WHERE no<>2;

    +------+-----------+
    | no   | name      |
    +------+-----------+
    |    1 | 박준용      |
    |    3 | 홍길동      |
    +------+-----------+
    2 rows in set (0.00 sec)
    ```

</div>

이전 `WHERE no=2`의 결괏값과 달리 `WHERE no<>2`를 통해 `no`의 값이 `2`가 아닌 행만 반환했습니다. 이처럼 여러 연산자를 통해 조건을 달리 설정하여 원하는 값을 얻을 수 있습니다.

이때 아래와 같이 조건식에 일치하는 행이 전혀 없는 경우에는 아무것도 반환되지 않습니다.

<div class="termy">
    ```sh
    $ mysql > SELECT no, name FROM sample21 WHERE no=4;

    Empty set (0.00 sec)
    ```

</div>

### 문자열형의 상수

수치형 뿐만 아니라 문자열, 날짜시간형 등의 모든 자료형을 조건으로 할 때도 방법은 동일합니다. 이때 유의할 점은 문자열의 경우 **싱글쿼트(`''`)**로 둘러싸 표기해야 하며 날짜시간형의 경우 연월일을 구분할 때는 **하이픈(`-`)**, 시분초를 구분할 때는 **콜론(`:`)**으로 구분하여 표기합니다.

예를 들어 `name` 열의 값이 `박준용`인 행을 조회하는 방법은 아래와 같습니다.

<div class="termy">
    ```sh
    $ mysql > SELECT no, name FROM sample21 WHERE name='박준용';

    +------+-----------+
    | no   | name      |
    +------+-----------+
    |    1 | 박준용    |
    +------+-----------+
    1 row in set (0.00 sec)
    ```

</div>

!!! info "정보"

    이때 자료형에 맞게 표기한 상수값을 **리터럴(Literal)**이라 합니다.

### `NULL`값 검색

조건식을 통해 원하는 값만 조회할 때 가장 유의해야 할 것은 바로 `=` 연산자로 `NULL`을 검색할 수 없다는 것입니다.

#### `IS NULL`

`NULL`을 검색할 때는 `IS NULL`이라는 연산자를 사용합니다. 예를 들어 `birthday`열의 값이 `NULL`인 행을 조회하는 방법은 아래와 같습니다.

<div class="termy">
    ```sh
    $ mysql > SELECT * FROM sample21 WHERE birthday IS NULL;

    +------+-----------+----------+---------------------------+
    | no   | name      | birthday | address                   |
    +------+-----------+----------+---------------------------+
    |    2 | 김재진      | NULL     | 대구광역시 동구              |
    |    3 | 홍길동      | NULL     | 서울특별시 마포구             |
    +------+-----------+----------+---------------------------+
    2 rows in set (0.00 sec)
    ```

</div>

반대로 `NULL` 값이 아닌 행을 표시하고 싶을 때는 다음과 같이 `IS NOT NULL`을 사용하면 됩니다.

<div class="termy">
    ```sh
    $ mysql > SELECt * FROM sample21 WHERE birthday IS NOT NULL;

    +------+-----------+------------+---------------------------+
    | no   | name      | birthday   | address                   |
    +------+-----------+------------+---------------------------+
    |    1 | 박준용    | 1976-10-18 | 대구광역시 수성구               |
    +------+-----------+------------+---------------------------+
    1 row in set (0.00 sec)
    ```

</div>

### 비교 연산자

`=`, `<>`, `IS NULL`, `IS NOT NULL` 외에도 다양한 연산자가 존재합니다. 대표적으로 사칙연산과 동일하게 `>`, `<`, `>=`, `<=`와 같은 **비교 연산자** 또한 존재합니다.

## 07강 조건 조합하기

논리 연산자를 통해 조건을 조합하여 더 세밀한 검색이 가능합니다.

### `AND`로 조합하기

복수의 조건을 조합할 경우 `AND` 논리 연산자를 사용합니다. 좌우의 식이 모두 참일 경우 참을 반환합니다. 따라서 `AND` 논리 연산자는 논리곱을 계산하는 **교집합**에 해당합니다.

예를 들어 아래와 같은 테이블 `sample24`가 있다고 가정해봅시다.

```sql
+------+------+------+------+
| no   | a    | b    | c    |
+------+------+------+------+
|    1 |    1 |    0 |    0 |
|    2 |    0 |    1 |    0 |
|    3 |    0 |    0 |    1 |
|    4 |    2 |    2 |    0 |
|    5 |    0 |    2 |    2 |
+------+------+------+------+
```

이때 `a`열과 `b`열의 값이 모두 `0`이 아닌 행을 검색하는 방법은 아래와 같습니다.

<div class="termy">
    ```sh
    $ mysql > SELECT * FROM sample24 WHERE a<>0 AND b<>0;

    +------+------+------+------+
    | no   | a    | b    | c    |
    +------+------+------+------+
    |    4 |    2 |    2 |    0 |
    +------+------+------+------+
    1 row in set (0.00 sec)
    ```

</div>

### `OR`로 조합하기

`OR` 논리 연산자의 경우 `AND`와 달리 어느 하나만 참이 되면 참이 됩니다. 따라서 `OR` 논리 연산자는 논리합을 계산하는 **합집합**에 해당합니다.

`a`열이 `0`이 아니거나 `b`열이 `0`이 아닌 행을 검색하는 방법은 아래와 같습니다.

<div class="termy">
    ```sh
    $ mysql > SELECT * FROM sample24 WHERE a<>0 OR b<>0;

    +------+------+------+------+
    | no   | a    | b    | c    |
    +------+------+------+------+
    |    1 |    1 |    0 |    0 |
    |    2 |    0 |    1 |    0 |
    |    4 |    2 |    2 |    0 |
    |    5 |    0 |    2 |    2 |
    +------+------+------+------+
    4 rows in set (0.00 sec)
    ```

</div>

### `AND`와 `OR`를 사용할 경우 주의할 점

열이나 상수만을 지정해도 오류가 발생하지는 않지만 원하는 결괏값이 아닐 수 있습니다. 상수의 경우 논리 연산 기준에서는 항상 참이 되기 때문입니다. 예를 들어 `SELECT * FROM sample24 WHERE no=1 OR 2;`라는 명령문에서 `WHERE no=1 OR 2`의 의미는 `no`열의 값이 `1` 또는 `2`가 아닌 `no`열의 값이 `1` 또는 뒤의 상수 `2`는 무조건 참이 됩니다. 따라서 해당 명령문은 모든 행을 반환하게 됩니다.

올바르게 `no`열의 값이 `1` 또는 `2`를 의미하는 조건식을 원한다면 `WHERE no=1 OR no=2`와 같이 작성해야 합니다.

#### `AND`와 `OR` 조합

`AND`와 `OR`을 조합할 수도 있습니다. 예를 들어 앞서 `AND` 논리 연산자 예시인, `a`열과 `b`열의 값이 모두 `0`이 아닌 행의 경우 `a`열이 `1` 또는 `2`이고, `b`열이 `1` 또는 `2`인 행을 검색하는 것과 동일합니다. 따라서 그 방법은 아래와 같습니다.

<div class="termy">
    ```sh
    $ mysql > SELECT * FROM sample24 WHERE a=1 OR a=2 AND b=1 OR b=2;

    +------+------+------+------+
    | no   | a    | b    | c    |
    +------+------+------+------+
    |    1 |    1 |    0 |    0 |
    |    4 |    2 |    2 |    0 |
    |    5 |    0 |    2 |    2 |
    +------+------+------+------+
    3 rows in set (0.00 sec)
    ```

</div>

그런데 앞선 결괏값과 다른 것을 볼 수 있습니다. 그 이유는 우선순위 때문입니다.

#### 연산자의 우선 순위

`OR` 보다 `AND`의 우선 순위가 더 높아 `a=1 OR a=2 AND b=1 OR b=2`에서 `a=2 AND b=1` 조건이 먼저 계산됩니다. 이럴 때는 사칙연산과 마찬가지로 괄호(`()`)을 사용하여 우선 순위를 지정해줄 수 있습니다. 따라서 아래와 같은 방법으로 원하는 결괏값을 얻을 수 있습니다.

<div class="termy">
    ```sh
    $ mysql > SELECT * FROM sample24 WHERE (a=1 OR a=2) AND (b=1 OR b=2);
    
    +------+------+------+------+
    | no   | a    | b    | c    |
    +------+------+------+------+
    |    4 |    2 |    2 |    0 |
    +------+------+------+------+
    1 row in set (0.00 sec)
    ```

</div>

### `NOT`으로 조합

`AND`, `OR` 외에도 `NOT` 논리 연산자 또한 존재합니다. `AND`, `OR` 논리 연산자가 좌우 항목을 필요로 하는 **이항 연산자**라면 `NOT` 논리 연산자의 경우 우측에만 항목을 지정하는 **단항 연산자**입니다.

`a`열이 `0`이 아니거나 `b`열이 `0`이 아닌 행을 제외한 나머지 행을 검색하는 방법은 아래와 같습니다.

<div class="termy">
    ```sh
    $ mysql > SELECT * FROM sample24 WHERE NOT (a<> 0 OR b <> 0);

    +------+------+------+------+
    | no   | a    | b    | c    |
    +------+------+------+------+
    |    3 |    0 |    0 |    1 |
    +------+------+------+------+
    1 row in set (0.00 sec)
    ```

</div>

## 08강 패턴 매칭에 의한 검색

`=`을 통해서 검색할 때 값이 완전히 동일한지 비교하여 결괏값을 반환했습니다. 하지만 특정 문자 또는 문자열이 포함되어 있는지를 검색하고 싶은 경우도 존재하기 때문에 이를 위해 등장한 게 바로 **패턴 매팅** 또는 **부분 검색**입니다. 예를 들어 검색창에 **SQL**을 검색했을 때 **SQL**이라는 문자열이 단어 내에 포함된 **MySQL**과 **PostgreSQL** 모두가 검색되게 하는 경우입니다.

### `LIKE`로 패턴 매칭하기

`LIKE` 술어를 사용하면 `=` 연산자와 달리 열 값이 부분적으로 일치하는 경우에도 참이됩니다. 명령문의 형태는 `열명 LIKE '패턴'`과 같으며 이때 `%` 또는 `_`와 같은 **메타문자**를 사용할 수 있습니다.

**와일드카드**라고도 불리는 이 **메타문자**는 패턴 매칭 시 임의의 문자 또는 문자열에 매치하는 부분을 지정하기 위해 쓰이는 특수 문자입니다. 패턴을 정의할 때 이 메타문자를 여러 개 사용할 수 있습니다. `LIKE`에서 사용되는 메타문자 두 가지의 의미는 다음과 같습니다.

* 퍼센트(`%`) : 임의의 문자열을 의미합니다.
* 언더스코어(`_`) : 임의의 문자 하나를 의미합니다.

아래와 같은 테이블 `sample25`가 있다고 가정해봅시다.

```sql
+------+-----------------------------------------------------------------+
| no   | text                                                            |
+------+-----------------------------------------------------------------+
|    1 | SQL은 RDBMS를 조작하기 위한 언어이다.                                  |
|    2 | LIKE에서는 메타문자 %와 _를 사용할 수 있다.                              |
|    3 | LIKE는 SQL에서 사용할 수 있는 술어 중 하나이다.                          |
+------+-----------------------------------------------------------------+
```

여기서 문자열 `SQL`을 폼하는 행을 패턴 매칭으로 검색하는 방법은 다음과 같습니다.

<div class="termy">
    ```sh
    $ mysql > SELECT * FROM sample25 WHERE text LIKE 'SQL%';

    +------+---------------------------------------------------+
    | no   | text                                              |
    +------+---------------------------------------------------+
    |    1 | SQL은 RDBMS를 조작하기 위한 언어이다.                    |
    +------+---------------------------------------------------+
    1 row in set (0.00 sec)
    ```

</div>

문제는 `no`열의 값이 `3`인 `text` 열의 값에도 `SQL`이 포함되어 있는데 반환되지 않았습니다. 그 이유는 `LIKE 'SQL%'`이 `SQL`이라는 문자가 맨 앞에 존재하고 그 뒤에 임의의 문자열(`%`)이 존재하는 행을 검색하라는 의미이기 때문입니다. 만약 앞뒤에 어떤 문자열이 존재하더라도 `SQL`만 들어있으면 되는 경우를 검색하고 싶다면 그 방법은 아래와 같습니다.

<div class="termy">
    ```sh
    $ mysql > SELECT * FROM sample25 WHERE text LIKE '%SQL%';

    +------+-----------------------------------------------------------------+
    | no   | text                                                            |
    +------+-----------------------------------------------------------------+
    |    1 | SQL은 RDBMS를 조작하기 위한 언어이다.                                  |
    |    3 | LIKE는 SQL에서 사용할 수 있는 술어 중 하나이다.                          |
    +------+-----------------------------------------------------------------+
    2 rows in set (0.00 sec)
    ```

</div>

여기서 중요한 점은 메타문자인 `%`가 빈 문자열과도 매치하는 것입니다. 다시 말해 `text`열의 값이 `SQL은 RDBMS를 조작하기 위한 언어이다.`인 경우 `SQL` 문자열 앞에 어떤 문자열이 존재하지 않는, 빈 문자열임에도 `LIKE '%SQL%'` 조건에 일치하여 반환되었습니다.

* 전방 일치 : `SQL%`과 같이 문자열 앞쪽에 지정한 문자와 일치하는 경우를 **전방 일치**라 합니다.
* 중간 일치 : `%SQL%`과 같이 지정 문자열이 중간에 있어 지정한 문자 앞뒤로 임의의 문자열이 존재하는 경우를 **중간 일치**라 합니다.
* 후방 일치 : `%SQL`과 같이 문자열 뒤쪽에 지정한 문자와 일치하는 경우를 **후방 일치**라 합니다.

### `LIKE`로 `%`를 검색하기

`text` 열의 값이 `LIKE에서는 메타문자 %와 _를 사용할 수 있다.`와 같은 경우 문자열 내에 `%`와 `_` 같은 메타문자를 포함하고 있습니다. 이때는 `\`를 사용하여 이스케이프(`\`) 처리해 원하는 메타문자를 검색 조건으로 포함할 수 있습니다. 그 방법은 아래와 같습니다.

<div class="termy">
    ```sh
    $ mysql > SELECT * FROM sample25 WHERE text LIKE '%\%%';

    +------+------------------------------------------------------------+
    | no   | text                                                       |
    +------+------------------------------------------------------------+
    |    2 | LIKE에서는 메타문자 %와 _를 사용할 수 있다.                        |
    +------+------------------------------------------------------------+
    1 row in set (0.00 sec)
    ```

</div>

!!! info "정보"

    프로그래밍에서 **이스케이프(Escape)**란 프로그래밍 특성상 표현할 수 없는 문자를 표현하는 방법을 의미합니다.

### 문자열 상수 `'`의 이스케이프!

메타문자를 검색할 때와 마찬가지로 문자열 상수를 검색할 경우 `'`을 (`''`)와 같이 연속으로 기술하여 이스케이프 처리를 할 수 있습니다. 예를 들어 `It's`라는 문자열을 검색하고 싶을 때 `LIKE 'It''s'`와 같이 조건을 작성할 수 있습니다. 또한 `'`하나만 존재할 경우 `LIKE ''''`와 같이 써서 검색 가능합니다. 겉을 감싸는 `''`와 `'`을 검색하기 위해 `'`을 연속으로 기술한 `''`이 존재하는 형태입니다.

!!! info "정보"

    간단한 패턴 매칭의 경우 `LIKE`를 사용하면 되지만 훨씬 복잡한 패턴 또한 존재합니다. 대부분의 데이터베이스가 **정규 표현식(Regular Expression)**을 지원하기 때문에 그럴 때는 정규 표현식을 사용하는 게 훨씬 효율적입니다.