---
title: "개발에도 최최최종 파일이 있다고요?"
description: "[ Soft-Where ] 개발에도 최최최종 파일이 있다고요? "
tags:
    - "2021"
    - Soft-Where
---

# 개발에도 최최최종 파일이 있다고요?

!!! note "오늘 배워볼 개념"

    1. Git과 GitHub
    2. 이 두가지를 통한 협업 방식

<img src="https://weekwith.me/images/soft-where/01/0.png">

## 도입

학교 과제를 하거나 일을 할 때 분명 끝난 것 같은데 파일을 다시 수정하거나 보완해야 할 때가 많습니다. 그럴 때는 기존에 존재하던 **최종.ppt**를 놔두고 새로운 **최종_v1.ppt**를 만들고는 합니다. 그러다 결국 이미지와 같이 쌓여가는 '**최종이**'를 다들 한 번쯤은 경험해보셨을 것 같습니다.

예를 들어 하나의 애플리케이션에도 수많은 버전이 존재하듯 프로그래밍에도 수많은 최종이가 존재합니다. 그렇다면 개발자는 과연 어떻게 이 최종이를, 다시 말해 어떻게 파일을 관리할 수 있을까요?

## Git

<img src="https://weekwith.me/images/soft-where/01/1.png">


개발에는 **깃(Git)**이라는 게 존재합니다. 깃은 멋지게 표현하면 **분산 버전 관리 시스템(VCS_Version Control System)**이라고 합니다. 단어 그대로 분산된 버전을 관리할 수 있게 도와주는, 다시 말해 늘어나는 최종이를 쉽게 관리할 수 있게 도와주는 시스템입니다. 그렇다면 깃을 사용해서 얻을 수 있는 장점은 과연 무엇일까요?

깃에는 **커밋(Commit)**이라는 개념이 있습니다. 그렇다면 커밋의 의미는 무엇일까요? 깃에서의 커밋이 무엇을 의미하는 지 검색해보면 보통 아래와 같이 뜹니다.

> *프로젝트의 최근 단계적 변경 사항에 대한 스냅샷을 저장한다.*  
> *Caputes a snapshot of the project's currently staged changes.*

잠깐, 잠깐! 갑자기 너무 어려워졌죠? 우리가 기억해야 할 부분은 딱 이겁니다.

> *변경 사항을 저장한다.*

**Commit**을 네이버 영어 사전에 한 번 검색해볼까요? 아래 이미지와 같은 정의를 볼 수 있습니다.

<img src="https://weekwith.me/images/soft-where/01/2.png">

**~을 마음에 새기다[기억하다]**라는 의미가 곧 깃에서의 **커밋**이 의미하는 바입니다. 그러면 단순히 기억만 한다고 해서 버전을 잘 관리할 수 있을까요? 기록이 필요합니다.

예를 들어 **최종.ppt** 파일과 **최종_v1.ppt** 파일의 차이점은 무엇일까요? 파일 이름만 봐서는 잘 모르겠죠? 그래서 깃은 커밋을 할 때 문장을 작성할 수 있게 해줍니다. 이를 보통 **커밋 내역(Commit Log)**를 남긴다고 표현합니다.

그래서 아래와 같이 개발자들이 까만 터미널 창을 열어서 `git log` 명령어를 입력하면 `:memo: FastAPI Translation as Korean` 또는 `:memo: Pydantic, Staelette, SQLModel translation as Korean`과 같은 기록들을 알 수 있게 됩니다.

<div class="termy">
    ```sh
    $ git log

    commit 2f03ab8bf6389cac7061ddd48dc98caceddf8dbd
    Author: 2_taehyun <63915557+0417taehyun@users.noreply.github.com>
    Date:   Sat Oct 30 23:31:52 2021 +0900

        :memo: FastAPI Translation as Korean

    commit bb24a02ee605da4bced94809ae10d54975554951
    Author: 2_taehyun <63915557+0417taehyun@users.noreply.github.com>
    Date:   Sat Oct 30 17:46:10 2021 +0900

        :memo: Pydantic, Starlette, SQLModel translation as Korean
    ```
</div>

이를 통해서 해당 버전에 어떤 변화가 생겼는 지 한 눈에 알 수 있게 되는 것입니다. 그렇다면 이러한 기록은 왜 중요할까요?

사실 본인이 잘 기억만 하고 있으면 위 예시와 같은 자세한 기록을 남기지 않더라도 충분히 관리가 가능해집니다. 하지만 카카오톡과 같은 애플리케이션을 보더라도 한 명의 개발자가 모든 기능을 만들지는 않습니다. 다시 말해 **협업**이 불가피한 것입니다.

따라서 다른 개발자와의 협업을 위해 이해하기 쉬운, 직관적인 **커밋 내역**을 남기는 게 중요한 것입니다. 그런데 내가 만들고 있는 이 프로그램을 어떻게 다른 사람과 공유할 수 있을까요? 

## GitHub

<img src="https://weekwith.me/images/soft-where/01/3.png">

깃헙(GitHub)은 깃을 통해서 파일들, 다시 말해 소스 코드를 관리해주는 호스팅 플랫폼입니다. 쉽게 노트북에서 작성한 **최종.ppt** 파일을 마치 **구글 독스**처럼 다른 사람들이 함께 참여해서 수정할 수 있게 도와주는 서비스입니다.

이때 **저장소(Repository)**라는 개념으로 하나의 저장 공간을 만들어서 이를 협업하는 사람들이 같이 관리하게 됩니다. 아래 이미지와 같이 *Contributors* 부분을 통해 단어 그대로 해당 코드에 대해 기여(Contribute)를 한, 작업을 한 사람들을 알 수 있습니다.

<img src="https://weekwith.me/images/soft-where/01/4.png">

!!! info "정보"

    **저장소(Repostitory)**는 보통 두 가지 개념으로 나뉩니다.

    내 컴퓨터에서 작업을 하는 저장소를 **지역 저장소(Local Repository)**라고 하며, 깃헙과 같은 호스팅 플랫폼에 올라가 있는 저장소를 **원격 저장소(Remote Repository)**라고 합니다.


정리해보면 다음과 같습니다.

{==
**깃**을 통해서 어떤 특정 작업에 대해 **내역(Log)**을 남기고, 그렇게 버전 관리된 파일을 **깃헙**을 통해서 사람들과 공유하고 협업하여 멋진 애플리케이션을 만든다!
==}

그런데 이런 의문이 들 수 있습니다. 만약에 내가 작성한 코드를 다른 사람이 모르고 날려버리면 어떡하지?

이를 위해서 깃에는 특별한 개념이 등장합니다.

## 협업 방식

깃은 **분기(Branch)**를 나눌 수 있습니다. 다시 말해 하나의 **최종.ppt** 파일을 기준으로 **A**라는 사람과 **B**라는 사람이 각각 **최종_A.ppt**, **최종_B.ppt** 파일을 만든 다음 본인의 작업만 마무리 한 다음에 이를 **최종.ppt** 파일에 합치는 것처럼 `A`, `B`라는 형태로 분기하여 각자 작업한 뒤 하나의 메인(`main`)에 합칠 수 있는 것입니다.

!!! info "정보"

    본래 기본 분기(Branch)는 `master`였으나 `master`의 의미가 **master**와 **slave** 같이 주종 관계, 즉 노예 제도를 연상시키는 문제 때문에 현재는 `main`이 기본입니다.

    물론 해당 기본 분기 이름을 `master` 또는 `develop` 등으로 마음껏 변경할 수 있습니다.

글로는 감이 잘 안 오니까 아래 이미지를 한 번 살펴봅시다.

<img src="https://weekwith.me/images/soft-where/01/5.png">

**풀 리퀘스트(Pull Request)**는 말 그대로 본인이 작업한 내용을 메인(`main`) 분기에, 다시 말해 **최종_A.ppt**에서 작업한 내용을 **최종.ppt**에 합쳐달라는 **요청(Request)**을 의미합니다.

*into `main` from `0417taehyun`* 부분을 보시면 알겠지만 `0417taehyun`이라는 분기에서 작업한 내용을 `main` 분기에 합쳐달라는 요청입니다.

또한 *Files changed*와 같은 부분을 통해서 쉽게 `main` 분기와 다른 부분을 확인할 수 있습니다.

끝으로 *Merged*라는 보라색 부분을 보아 성공적으로 `0417taehyun`에서 수행한 작업이 `main`에 **병합(Merge)**, 다시 말해 합쳐졌다는 것도 알 수 있습니다.

!!! info "정보"

    만약 **A**라는 사람이 **최종_A.ppt** 파일의 두 번째 슬라이드에 존재하던 *파인애플* 🍍이라는 단어를 *바나나* 🍌라는 단어로 수정하여 **최종.ppt** 파일에 합쳤다고 가정해봅시다.
    
    이때 **B**라는 사람이 **최종_B.ppt** 파일을 최신화 시키지 않는다면 해당 부분의 단어는 여전히  *파인애플* 🍍입니다. 이후 본인의 작업을 끝내고 **최종.ppt** 파일에 이를 합칠 경우 기존의 변경한 작업, 다시 말해 *바나나* 🍌가 아닌 *파인애플* 🍍로 **최종.ppt** 파일이 저장되는 불상사가 발생합니다.

    개발에서도 최신화된 버전이 적용되지 않은 채 메인(`main`) 분기에 본인의 작업을 병합(Merge)하려는 시도를 하면 위와 같은 불상사를 막기 위해 **충돌(Conflict)**이 발생했다고 알려줍니다.

정리해보면 다음과 같습니다.

{==
프로그래밍을 통해 무엇인가 만들 때 다른 사람의 작업을 건들지 않기 위해서 팀원들이 각자 **분기(Branch)**하여 개별적으로 작업한 뒤 이를 메인 분기에 **합쳐(Merge)**달라는, **풀 리퀘스트(Pull Request)**라는 요청을 한다.
==}


## 결론

오늘 배운 개념을 정리하면 아래와 같습니다.

* 깃(Git)과 깃헙(GitHub)
    * 커밋(Commit)과 커밋 내역(Commit Log)
    * 저장소(Repository)
* 깃(Git)과 깃헙(GitHub)을 통한 협업 방식
    * 분기(Branch)
    * 풀 리퀘스트(PR_Pull Request)와 병합(Merge)


결국 팀 프로젝트를 통해서 하나의 **최종.ppt** 파일을 관리하듯 개발자들도 깃(Git)과 깃헙(GitHub)을 활용해 효율적인 협업을 하게됩니다.

이때 커밋(Commit)을 통해 작업 내역(Log)을 남기고 하나의 저장소(Repository)에 최종적으로 합칠 메인(`main`)을 관리하며, 각자가 하는 작업은 분기(Branch)를 통해서 진행하여 충돌(Conflict)이 없게 하고 이를 메인(`main`)에 합치게(Merge) 됩니다.